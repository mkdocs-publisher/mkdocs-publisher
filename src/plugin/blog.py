import logging
from collections import OrderedDict
from copy import deepcopy
from datetime import datetime
from pathlib import Path
from typing import Any
from typing import Dict
from typing import Optional
from typing import cast

from mkdocs.config import Config
from mkdocs.config.defaults import MkDocsConfig
from mkdocs.plugins import BasePlugin
from mkdocs.structure.files import Files
from mkdocs.structure.nav import Navigation
from mkdocs.structure.pages import Page

from src.plugin import modifiers
from src.plugin import parsers
from src.plugin import rendereres
from src.plugin.config import BlogInPluginConfig
from src.plugin.structures import BlogPost

log = logging.getLogger("mkdocs.plugins.blog-in")


class BlogInPlugin(BasePlugin[BlogInPluginConfig]):
    def __init__(self):
        self.blog_posts: Dict[datetime, BlogPost] = {}
        self.temp_files: Dict[str, Path] = {}

    def on_config(self, config: MkDocsConfig) -> Config:

        # New config navigation
        config_nav = OrderedDict()

        parsers.parse_markdown_files(
            blog_posts=self.blog_posts,
            config_nav=config_nav,
            docs_dir=Path(str(config.docs_dir)),
            posts_dir=Path(self.config.posts_dir),
        )

        parsers.create_blog_post_teaser(
            blog_posts=self.blog_posts, teaser_marker=self.config.teaser_marker
        )

        rendereres.create_blog_post_pages(
            blog_posts=self.blog_posts,
            temp_files=self.temp_files,
            config_nav=config_nav,
            docs_dir=Path(str(config.docs_dir)),
            config=self.config,
        )

        modifiers.blog_post_nav_sorter(
            blog_posts=self.blog_posts,
            config_nav=config_nav,
            posts_dir=Path(self.config.posts_dir),
        )

        # Override nav section
        config.nav = config_nav

        return config

    def on_nav(self, nav: Navigation, config: MkDocsConfig, files: Files) -> Navigation:
        modifiers.blog_post_nav_remove(
            nav=nav, blog_posts=self.config.posts_dir, config=self.config
        )

        return nav

    def on_files(self, files: Files, config: MkDocsConfig) -> Files:

        new_files = modifiers.blog_post_slug_modifier(
            blog_posts=self.blog_posts, files=files, site_dir=Path(str(config.site_dir))
        )

        return new_files

    def on_page_markdown(self, markdown: str, *, page: Page, config: MkDocsConfig, files: Files):
        # Modify page update date
        # TODO: move date format to config
        update_date: datetime = page.meta.get(
            "update", page.meta.get("date", datetime.strptime(page.update_date, "%Y-%m-%d"))
        )
        page.update_date = update_date.strftime("%Y-%m-%d")

    def on_page_context(
        self, context: Dict[str, Any], *, page: Page, config: MkDocsConfig, nav: Navigation
    ) -> Optional[Dict[str, Any]]:

        # TODO: move str names into config
        if page.title == "index":
            page.title = "Home"
            if page.next_page is not None and str(page.next_page.title).startswith("index-"):
                next_page_copy = cast(Page, deepcopy(page.next_page))
                next_page_copy.title = "Next posts"
                page.next_page = next_page_copy
        if str(page.title).startswith("index") or (
            page.previous_page is not None and str(page.previous_page.title).startswith("index")
        ):
            previous_page_copy = cast(Page, deepcopy(page.previous_page))
            previous_page_copy.title = "Previous posts"
            page.previous_page = previous_page_copy
            if page.next_page is not None and str(page.next_page.title).startswith("index-"):
                next_page_copy = cast(Page, deepcopy(page.next_page))
                next_page_copy.title = "Next posts"
                page.next_page = next_page_copy

        return context

    def on_post_build(self, *, config: MkDocsConfig) -> None:

        # Remove autogenerated posts index files
        for temp_file in self.temp_files.values():
            temp_file.unlink(missing_ok=True)
